#include <iostream>
using namespace std;

// boolean, floatPoing

// boolean true, false

bool isHighLevel = true;
bool isPlayer = true;
bool isMale = false;

// bool은 그냥 1바이트의 정수에 불과
// 어셈블리에 bool 이라는 것은 없음
// bool만 봐도 참/거짓 둘 중 하나라는 뜻 (가독성이 좋음)

int isFemale = 1;

// bool < 1바이트 정수
// - al

// 실수 (부동소수점)
// 3.141592
// 소수점 앞/뒤를 기준으로 16비트씩 끊어서 하면?
// (0.65535) . (0.65535) 즉 표현할 수 있는 수가 그리 크지 않음

// 따라서 부동소수점을 이용함
// 부동소수점에서 부동은 움직이지 않다라는 뜻X 
// float 즉 소수점을 유동적으로 움직여서 표현함

// 3.141592
// 3.141592 = 0.3141592 * 10 = 314.1592 * 10^-2
// 1) 정규화 = .3141592 * 10
// 2) 3141592 (유효숫자) 1 (지수)

// float 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4바이트
// double 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8바이트

float attackSpeed = -3.375f; // 4바이트
double attackSpeed2 = 123.2323; // 8바이트

// ex) -3.375 라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 uinsigned byte라고 가정하고 숫자 +127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000'0000'0000'0000'0000

// 프로그래밍할 때 부동소수점은 항상 '근사값'이라는 것을 기억해야함
// 1/3 = 0.3333333333333333333333
// 특히 수가 커질 수록 오차 범위도 매우 커짐
// 실수 2개를 == 으로 비교하는 것은 지양해야함

// ex) 123.2323 라는 값을 저장
// 1) 2진수 변환 = (123) + (0.2323) = 0b1111011 + 0b
// 123.2323 = 0.5 * 0 + 0.25 * 0 + 0.125 * 


float debuffSpeed = -3.375f;
double staminaRegen = 17.27182;


int main()
{
	if (isMale == 1);

} 